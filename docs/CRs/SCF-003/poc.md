# Proof of Concept: SCIP Property/Method Suffix Support

**CR**: SCF-003
**Date**: 2026-01-04
**Status**: ✅ **COMPLETE - Hypothesis Validated**

---

## Executive Summary

**Hypothesis**: SCIP indexes contain distinguishable property (`.`) and method (`().`) references.

**Answer**: ✅ **PROVEN** - Found direct evidence in real SCIP indexes and scip-typescript source code.

**Key Finding**: The limitation is **NOT** in SCIP protocol or schema — it's in scip-finder's symbol parsing logic, which strips suffix information.

---

## Question

> "Does SCIP actually emit property and method references in real indexes, or is this just theoretical protocol support?"

---

## Hypothesis

**What we expected**: SCIP indexes generated by scip-typescript contain distinguishable property (`.` suffix) and method (`().` suffix) references that can be extracted and queried.

**Success Criteria**:
- [x] Can find a property reference (with `.` suffix) in an actual SCIP index
- [x] Can find a method reference (with `().` suffix) in an actual SCIP index
- [x] Can demonstrate the suffix distinction is preserved in the data

---

## Experiment

### Approach

Three-pronged validation strategy:

1. **Direct SCIP Index Inspection** - Extract symbols from real `.scip` file
2. **scip-typescript Source Analysis** - Examine how indexer generates suffixes
3. **Protocol Specification Review** - Verify SCIP proto defines suffix types

### Spike Location

- `docs/CRs/SCF-003/poc/validate-suffix-in-index/` - Validation scripts (created by subagent aa6f1a4)
- `/tmp/scip-typescript-research/` - Cloned repository for source analysis

---

## Findings

### 1. Direct Evidence from SCIP Index

**File**: `/Users/kirby/home/scip-finder/index-unified.scip`

#### Method References (ending with `().`)

```
scip-typescript npm @types/node 20.19.27 `process.d.ts`/`"process"`/global/NodeJS/Process#cwd().
scip-typescript npm @types/node 20.19.27 `path.d.ts`/`"path"`/path/PlatformPath#join().
scip-typescript npm @types/node 20.19.27 `path.d.ts`/`"path"`/path/PlatformPath#dirname().
scip-typescript npm @types/node 20.19.27 `buffer.d.ts`/`"buffer"`/global/Buffer#toString().
scip-typescript npm typescript 5.9.3 lib/`lib.es5.d.ts`/String#trim().
scip-typescript npm typescript 5.9.3 lib/`lib.es2015.core.d.ts`/String#startsWith().
scip-typescript npm typescript 5.9.3 lib/`lib.es5.d.ts`/JSON#parse().
scip-typescript npm protobufjs 8.0.0 `index.d.ts`/NamespaceBase#lookupType().
```

**Pattern**: Methods consistently end with `().` (parentheses followed by dot)

#### Property References (ending with `.`)

```
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/projectRoot.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/protoPath.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/ScipIndex#metadata.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/ScipIndex#documents.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/ScipIndex#externalSymbols.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/ScipDocument#relativePath.
scip-typescript npm scip-finder 0.0.1 src/core/`scip-loader.ts`/ScipDocument#language.
```

**Pattern**: Properties consistently end with `.` (dot only)

---

### 2. scip-typescript Implementation

**Repository**: https://github.com/sourcegraph/scip-typescript
**Cloned to**: `/tmp/scip-typescript-research/`

#### Suffix Assignment Logic

**File**: `src/scip.ts` (Lines 1063-1074)

```typescript
export namespace Descriptor {
  export enum Suffix {
    UnspecifiedSuffix = 0,
    Namespace = 1,      // '/'
    Type = 2,           // '#'
    Term = 3,           // '.'  ← PROPERTIES
    Method = 4,         // '().' ← METHODS
    TypeParameter = 5,  // '[]'
    Parameter = 6,      // '()'
    Meta = 7,           // ':'
    Local = 8,          // ''
  }
}
```

#### Descriptor Creation

**File**: `src/Descriptor.ts` (Lines 36-52)

```typescript
export function descriptorString(desc: Descriptor): string {
  switch (desc.suffix) {
    case Suffix.Term: {
      return escapedName(desc) + '.'           // Properties get '.'
    }
    case Suffix.Method: {
      return escapedName(desc) + '(' + (desc.disambiguator || '') + ').'  // Methods get '().'
    }
    // ... other cases
  }
}
```

#### Property vs Method Detection

**File**: `src/FileIndexer.ts` (Lines 541-560)

```typescript
private descriptor(node: ts.Node): scip.scip.Descriptor | undefined {
  // Methods get Method suffix
  if (
    ts.isFunctionDeclaration(node) ||
    ts.isMethodSignature(node) ||
    ts.isMethodDeclaration(node)
  ) {
    const name = node.name?.getText()
    if (name) {
      return methodDescriptor(name)  // Returns Suffix.Method
    }
  }

  // Properties get Term suffix
  if (
    ts.isPropertyDeclaration(node) ||
    ts.isPropertySignature(node) ||
    ts.isEnumMember(node) ||
    ts.isVariableDeclaration(node)
  ) {
    return termDescriptor(node.name.getText())  // Returns Suffix.Term
  }
}
```

---

### 3. Test Evidence from scip-typescript

**Test File**: `snapshots/input/syntax/src/interface.ts`

```typescript
export interface Interface {
  property: string
  methodSignature(param: string): string
  methodSignature2: (param: string) => string
}
```

**Output** (`snapshots/output/syntax/src/interface.ts`):

```
//^^^^^^^^ definition syntax 1.0.0 src/`interface.ts`/Interface#property.
//^^^^^^^^^^^^^^^ definition syntax 1.0.0 src/`interface.ts`/Interface#methodSignature().
//^^^^^^^^^^^^^^^^ definition syntax 1.0.0 src/`interface.ts`/Interface#methodSignature2.
```

**Critical Distinction**:
- `property: string` → `Interface#property.` (PropertySignature → Term suffix)
- `methodSignature(): string` → `Interface#methodSignature().` (MethodSignature → Method suffix)
- `methodSignature2: () => string` → `Interface#methodSignature2.` (PropertySignature → Term suffix, because it's a property holding a function type)

---

### 4. What Works

✅ **SCIP Protocol** - Defines suffix types in `scip.proto`:
  - `Suffix.Term = 3` (`. `) for properties
  - `Suffix.Method = 4` (`().`) for methods

✅ **scip-typescript** - Correctly generates suffixes:
  - Properties get `.` suffix via `termDescriptor()`
  - Methods get `().` suffix via `methodDescriptor()`
  - Distinction based on TypeScript AST node types

✅ **SCIP Index Data** - Real indexes contain suffixed symbols:
  - Methods: `Process#cwd().`, `String#trim().`, `JSON#parse().`
  - Properties: `ScipIndex#metadata.`, `ScipDocument#relativePath.`

---

### 5. What Doesn't Work (Current Limitation)

❌ **scip-finder Symbol Parsing** - Strips suffix information

**File**: `src/utils/symbol-parser.ts:22`

```typescript
export function extractDisplayName(symbol: string): string {
  const match = symbol.match(/\/([^\/#.]+?)(\(\)|\(.*?\))?[.#]?$/);
  return match ? match[1] + (match[2] || '') : '';
  // Problem: Strips '.', '#', '().' suffixes
}
```

**Result**: `Ticket#title.` becomes `title` → **loses property context**

---

### 6. Constraints Discovered

| Constraint | Impact |
|------------|--------|
| Suffix is part of symbol identifier | Properties and methods are distinct symbols in SCIP |
| Symbol keys don't preserve suffix | scip-finder creates collisions (e.g., `title.` = `title` = `title().`) |
| No protocol change needed | Enhancement is purely in scip-finder parsing logic |
| Backward compatibility possible | Can add suffix support while maintaining existing queries |

---

### 7. Performance Characteristics

Not measured in this PoC (focused on functional correctness), but:

- SCIP indexes already contain suffix data (zero additional storage cost)
- Query performance impact expected to be minimal (string suffix matching)
- scip-typescript already generates suffixes (zero indexing cost)

---

## Decision

**Answer**: ✅ **YES** - SCIP indexes DO contain property and method references with distinguishable suffixes.

**Recommended Approach**:

1. **Update scip-finder symbol parsing** to preserve suffix:
   ```typescript
   export function extractDisplayName(symbol: string): string {
     // Keep the suffix for proper distinction
     const match = symbol.match(/\/([^\/#]+?)(\(\)|\(.*?\))?([.#])?$/);
     return match ? match[1] + (match[2] || '') + (match[3] || '') : '';
   }
   ```

2. **Update symbol key generation** to include suffix:
   ```typescript
   export function getSymbolKey(symbol: string): string {
     const suffix = extractSuffix(symbol);
     return `${packageName}:${path}:${name}:${suffix}`;
   }
   ```

3. **Add suffix-aware query filters**:
   ```bash
   scip-finder --suffix term ClassName     # Properties only
   scip-finder --suffix method ClassName   # Methods only
   scip-finder ClassName                   # All members (backward compatible)
   ```

**Rationale**: The SCIP protocol, schema, and scip-typescript indexer all support property/method references. Only scip-finder needs enhancement to parse and query symbols with suffixes correctly.

**Alternatives Eliminated**:
- ❌ SCIP protocol upgrade (not needed - already supported)
- ❌ SCIP schema upgrade (not needed - fields exist)
- ❌ scip-typescript modification (not needed - already works)

---

## Impact on Architecture

| Aspect | Implication |
|--------|-------------|
| **Protocol/Schemas** | No changes required - SCIP already supports suffixes |
| **scip-typescript** | No changes required - already generates correct suffixes |
| **scip-finder Parsing** | Requires update to preserve suffix in symbol parsing |
| **scip-finder Querying** | Requires suffix-aware filter logic |
| **CLI Interface** | Add `--suffix` flag for targeted queries |
| **Backward Compatibility** | Maintain existing query behavior (search all suffixes) |

---

## Cleanup

- [x] PoC code is throwaway — do not adapt to production
- [x] Pattern worth adapting: Suffix detection regex and key generation

---

## Next Steps

1. **Create Implementation CR** (SCF-004) - Add property/method reference support to scip-finder
2. **Update scip-finder Documentation** - Remove "does not work for properties" statement
3. **Implement Suffix-Aware Parsing** - Update symbol-parser.ts to preserve suffix
4. **Add Query Filters** - Implement `--suffix` CLI flag
5. **Test Real Scenarios** - Validate with actual property/method queries

Architecture can now proceed with validated approach:

```bash
/mdt:architecture SCF-003
```

---

## Sources

### Direct Evidence
- **SCIP Index**: `/Users/kirby/home/scip-finder/index-unified.scip` - Real data with suffixes
- **scip-typescript Source**: `/tmp/scip-typescript-research/` - Implementation details

### Code References
- `src/scip.ts:1063-1074` - Suffix enum definition
- `src/Descriptor.ts:36-52` - Descriptor string formatting
- `src/FileIndexer.ts:541-560` - Property vs method detection
- `snapshots/output/syntax/src/interface.ts` - Test evidence

### Research Documents
- `docs/CRs/SCF-003/research_scip_property_method_support_20250104.md` - Original investigation

### External Sources
- [SCIP Protocol - scip.proto](https://github.com/sourcegraph/scip/blob/main/scip.proto)
- [scip-typescript Repository](https://github.com/sourcegraph/scip-typescript)

---

**Proof Complete**: Empirical evidence from real SCIP indexes, source code analysis, and test data all confirm that SCIP supports property and method references through distinguishable suffixes. The limitation is purely in scip-finder's parsing logic, not in the SCIP protocol or schema.

---

# Appendix: Method Parameter Investigation

**Date**: 2026-01-04
**Question**: "What does SCIP database return for requesting a method parameter?"

## Hypothesis

**Expected**: SCIP stores method parameters using the `Parameter` suffix (enum value 6, character `()`), and they can be queried similar to properties and methods.

**Alternative**: Parameters are stored as LOCAL symbols (`local N` format) and are not queryable across documents.

## Experiment

**Spike Location**: `docs/CRs/SCF-003/poc/parameter-investigation/`

**Approach**: Symbol pattern analysis to verify parameter symbol format

## Findings

### Critical Discovery: Parameters are LOCAL Symbols

**SCIP Protocol Definition** (scip.proto line 156):

```protobuf
<symbol> ::= <scheme> ' ' <package> ' ' (<descriptor>)+ | 'local ' <local-id>
```

**Two symbol formats**:
1. **Global**: `scip-typescript myPackage/ Module#method().` (descriptor-based)
2. **Local**: `local 42` (document-scoped, used for parameters)

### SCIP Symbol Types Comparison

| Suffix | Character | Symbol Format | Scope | Searchable | Example |
|--------|-----------|---------------|-------|------------|---------|
| Namespace | `/` | `package/` | Global | ✅ Yes | `models/` |
| Type | `#` | `Class#` | Global | ✅ Yes | `Ticket#` |
| Term | `.` | `property.` | Global | ✅ Yes | `title.` |
| Method | `().` | `method().` | Global | ✅ Yes | `save().` |
| **Parameter** | `()` | `(param)` | **LOCAL** | ❌ **No** | `local 42` |
| TypeParameter | `[]` | `[T]` | Global | ✅ Yes | `[T]` |

### Current scip-finder Parser Behavior

**Symbol**: `local 42`
**Parsed Output**: `` (empty string)
**Information Loss**: YES - local symbols are completely lost

## Decision

**Answer**: **NO — SCIP database does NOT support cross-document parameter reference queries.**

**Rationale**:

1. **Fundamental limitation**: Parameters are LOCAL symbols by SCIP design
   - Stored as `local N` format, not descriptor-based symbols
   - Scoped to their document only
   - Cannot be queried across files (unlike properties and methods)

2. **Protocol constraint**: SCIP specification defines parameters as local
   - Symbol grammar: `local <local-id>` for function-local variables
   - Global symbols: descriptor-based only (packages, types, terms, methods)
   - Parameters reference via `enclosing_symbol` protobuf field, not symbol lookup

3. **Current tool limitation**: scip-finder only handles global symbols
   - Index built on descriptor-based symbol lookups
   - No local symbol resolution capability
   - No `enclosing_symbol` relationship traversal

4. **Explicit exclusion**: SCF-002 intentionally excluded parameter indexing
   - Listed under "Out of scope"
   - Would require fundamentally different search mechanism

## Impact on Property/Method Architecture

| Aspect | Implication |
|--------|-------------|
| **Property/method search** | Parameters are OUT of scope — do not include in suffix filtering |
| **SCIP suffix support** | Implement only `Term` (.) and `Method` ().) suffixes, NOT `Parameter` () |
| **CLI flags** | `--suffix` flag should NOT include `parameter` option |
| **Testing** | No parameter test cases needed for property/method feature |
| **Documentation** | Explicitly document that parameters are not supported (local symbol limitation) |

### If Parameter Search is Required (Future Work)

This would require a **separate feature** with different architecture:

1. **Local symbol resolution**:
   - Parse `local N` format symbols
   - Traverse `enclosing_symbol` relationships
   - Document-scoped search only

2. **UI differentiation**:
   - Separate command (e.g., `scip-finder-local`)
   - Different output format (show enclosing method)
   - File-scoped by design

3. **Indexing changes**:
   - Build local symbol lookup table
   - Map `local N` → occurrence list
   - Link parameters to their enclosing methods

**Estimated effort**: 20-30 hours (separate from property/method enhancement)

## Conclusion

Parameter search is **architecturally distinct** from property/method reference search and should **NOT** be included in SCF-003 implementation. Parameters require a separate local symbol search feature with different design constraints.
