/**
 * Tests for: SCF-001 Phase 3
 * Phase: CLI + Output + Integration Tests
 * Requirements: R1, R2, R3, R6, R7, R8, R9, R10, R11
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import fs from 'fs';
import path from 'path';
import { runCli } from '../helpers/cli-runner';

describe('CLI Integration Tests', () => {
  const testScipPath = path.join(process.cwd(), 'tests/fixtures/index.scip');

  // Phase 3 - Requirement 11: CLI Help and Usage
  describe('CLI Help and Usage (R11)', () => {
    describe('when user runs --help', () => {
      it('should display usage information', () => {
        const result = runCli('--help');
        expect(result.exitCode).toBe(0);
        expect(result.stdout).toContain('scip-find');
        expect(result.stdout).toContain('Usage:');
        expect(result.stdout).toContain('Options:');
      });

      it('should show all available options', () => {
        const result = runCli('--help');
        expect(result.stdout).toContain('--from');
        expect(result.stdout).toContain('--folder');
        expect(result.stdout).toContain('--format');
        expect(result.stdout).toContain('--scip');
        expect(result.stdout).toContain('--help');
      });

      it('should show examples in help text', () => {
        const result = runCli('--help');
        expect(result.stdout).toMatch(/Examples?/i);
      });
    });

    describe('when user runs -h', () => {
      it('should display usage information', () => {
        const result = runCli('-h');
        expect(result.exitCode).toBe(0);
        expect(result.stdout).toContain('scip-find');
      });
    });
  });

  // Phase 3 - Requirement 8: SCIP File Discovery
  describe('SCIP File Discovery (R8)', () => {
    describe('when --scip argument is provided', () => {
      it('should load the SCIP file from the specified path', () => {
        // This test requires a valid SCIP file to exist
        if (!fs.existsSync(testScipPath)) {
          console.warn('Test SCIP file not found, skipping test');
          return;
        }
        const result = runCli(`Ticket --scip ${testScipPath}`);
        // Should not error on file loading
        expect(result.stderr).not.toContain('SCIP file not found');
      });
    });

    describe('when SCIP file does not exist', () => {
      it('should display error message and exit with code 1', () => {
        const result = runCli('--scip /nonexistent/index.scip Ticket');
        expect(result.exitCode).toBe(1);
        expect(result.stderr).toContain('SCIP file not found');
      });
    });

    describe('when SCIP file is not provided and not found', () => {
      it('should display error message indicating how to specify SCIP file', () => {
        // Create a temporary directory without index.scip
        const tempDir = '/tmp/scip-test-no-scip';
        if (!fs.existsSync(tempDir)) {
          fs.mkdirSync(tempDir, { recursive: true });
        }

        // Run CLI from temp directory (without index.scip)
        const result = runCli('Ticket', { cwd: tempDir });
        expect(result.exitCode).toBe(1);
        expect(result.stderr).toMatch(/scip.*file/i);
        expect(result.stderr).toContain('--scip');
      });
    });
  });

  // Phase 3 - Requirement 9: Error Handling - Invalid SCIP File
  describe('Error Handling - Invalid SCIP File (R9)', () => {
    describe('when SCIP file is corrupted', () => {
      it('should display parse error and exit with code 1', () => {
        const corruptedFile = path.join(process.cwd(), 'tests/fixtures/corrupted.scip');
        // Create a corrupted file
        fs.writeFileSync(corruptedFile, 'invalid protobuf data');

        const result = runCli(`--scip ${corruptedFile} Ticket`);

        expect(result.exitCode).toBe(1);
        expect(result.stderr).toMatch(/parse/i);

        // Cleanup
        fs.unlinkSync(corruptedFile);
      });
    });
  });

  // Phase 3 - Requirement 1: Symbol Search by Name
  describe('Symbol Search by Name (R1)', () => {
    beforeEach(() => {
      if (!fs.existsSync(testScipPath)) {
        console.warn('Test SCIP file not found, skipping tests');
      }
    });

    describe('when user provides a symbol name', () => {
      it('should search the SCIP index for matching symbols', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket`);
        expect(result.exitCode).toBe(0);
      });
    });

    describe('when no symbols match the provided name', () => {
      it('should display symbol not found message and exit with code 0', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} NonexistentSymbol`);
        expect(result.exitCode).toBe(0);
        expect(result.stdout).toMatch(/not found/i);
      });
    });
  });

  // Phase 3 - Requirements 2 & 3: Definition File and Folder Filtering
  describe('Filtering Options (R2, R3)', () => {
    beforeEach(() => {
      if (!fs.existsSync(testScipPath)) {
        console.warn('Test SCIP file not found, skipping tests');
      }
    });

    describe('when user provides --from argument', () => {
      it('should filter results to symbols from the specified file', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --from shared/models/Ticket.ts`);
        expect(result.exitCode).toBe(0);
      });
    });

    describe('when user provides --folder argument', () => {
      it('should filter occurrences to files within the specified folder', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --folder src/`);
        expect(result.exitCode).toBe(0);
      });
    });
  });

  // Phase 3 - Requirements 6 & 7: Output Formats
  describe('Output Formats (R6, R7)', () => {
    beforeEach(() => {
      if (!fs.existsSync(testScipPath)) {
        console.warn('Test SCIP file not found, skipping tests');
      }
    });

    describe('when --format text is specified', () => {
      it('should output results in grep-like format', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format text`);
        expect(result.exitCode).toBe(0);
        // Check for grep-like format: file:line:column:
        expect(result.stdout).toMatch(/^.+:\d+:\d+:/);
      });

      it('should include file path, line number, and column', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format text`);
        expect(result.exitCode).toBe(0);
        const lines = result.stdout.trim().split('\n');
        if (lines.length > 0) {
          // Each line should match pattern: path:line:column: role
          expect(lines[0]).toMatch(/^.+:\d+:\d+:/);
        }
      });
    });

    describe('when --format json is specified', () => {
      it('should output valid JSON', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        // Should be able to parse as JSON
        expect(() => JSON.parse(result.stdout)).not.toThrow();
      });

      it('should include symbol name and occurrences array', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const json = JSON.parse(result.stdout);
        expect(json).toHaveProperty('symbol');
        expect(json).toHaveProperty('occurrences');
        expect(Array.isArray(json.occurrences)).toBe(true);
      });

      it('should include file, line, column, and role fields for each occurrence', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const json = JSON.parse(result.stdout);
        if (json.occurrences.length > 0) {
          const occ = json.occurrences[0];
          expect(occ).toHaveProperty('file');
          expect(occ).toHaveProperty('line');
          expect(occ).toHaveProperty('column');
          expect(occ).toHaveProperty('role');
        }
      });

      it('should include boolean flags for each occurrence', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const json = JSON.parse(result.stdout);
        if (json.occurrences.length > 0) {
          const occ = json.occurrences[0];
          expect(occ).toHaveProperty('isDefinition');
          expect(occ).toHaveProperty('isReference');
          expect(occ).toHaveProperty('isImport');
          expect(occ).toHaveProperty('isExport');
          expect(typeof occ.isDefinition).toBe('boolean');
          expect(typeof occ.isReference).toBe('boolean');
          expect(typeof occ.isImport).toBe('boolean');
          expect(typeof occ.isExport).toBe('boolean');
        }
      });
    });

    describe('when format is not specified', () => {
      it('should use text format by default', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket`);
        expect(result.exitCode).toBe(0);
        // Should not be JSON
        expect(() => JSON.parse(result.stdout)).toThrow();
      });
    });

    describe('when invalid format value is provided', () => {
      it('should display error with valid options and exit with code 1', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format invalid`);
        expect(result.exitCode).toBe(1);
        expect(result.stderr).toMatch(/format/i);
        expect(result.stderr).toMatch(/text|json/i);
      });
    });
  });

  // Phase 3 - Requirement 10: Symbol Role Identification
  describe('Symbol Role Identification (R10)', () => {
    beforeEach(() => {
      if (!fs.existsSync(testScipPath)) {
        console.warn('Test SCIP file not found, skipping tests');
      }
    });

    describe('when displaying occurrence results', () => {
      it('should identify symbol role based on SCIP bitmask', () => {
        if (!fs.existsSync(testScipPath)) return;
        const result = runCli(`--scip ${testScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const json = JSON.parse(result.stdout);
        if (json.occurrences.length > 0) {
          const occ = json.occurrences[0];
          expect(occ).toHaveProperty('role');
          expect(typeof occ.role).toBe('string');
        }
      });
    });
  });

  // Phase 3 - Invalid Arguments
  describe('Invalid Arguments (R11)', () => {
    describe('when user provides invalid arguments', () => {
      it('should display error message and suggest using --help', () => {
        const result = runCli('--invalid-option Ticket');
        expect(result.stderr).toContain('--help');
      });
    });
  });
});
