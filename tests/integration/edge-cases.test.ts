/**
 * Tests for: SCF-001 Phase 4
 * Phase: Hardening (Edge Cases)
 * Requirements: R8, R9 - Error handling validation
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import fs from 'fs';
import path from 'path';
import { generateAllFixtures } from '../fixtures/edge-cases/scip-fixture-generator';
import { runCli } from '../helpers/cli-runner';

describe('Phase 4: Hardening - Edge Cases', () => {
  const fixturesDir = path.join(process.cwd(), 'tests/fixtures/edge-cases');

  // Generate fixtures before running tests
  beforeAll(async () => {
    await generateAllFixtures(fixturesDir);
  });

  // Requirement 9: SCIP file missing
  describe('when SCIP file is missing', () => {
    it('should display error message with file path and exit with code 1', () => {
      const result = runCli('--scip /nonexistent/path/index.scip Ticket');

      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('SCIP file not found');
      expect(result.stderr).toContain('/nonexistent/path/index.scip');
    });

    it('should suggest using --scip option if file not found', () => {
      const result = runCli('Ticket');

      expect(result.exitCode).toBe(1);
      expect(result.stderr).toMatch(/scip/i);
      expect(result.stderr).toContain('--scip');
    });
  });

  // Requirement 9: SCIP file corrupted
  describe('when SCIP file is corrupted', () => {
    const corruptedScip = path.join(fixturesDir, 'corrupted.scip');

    it('should display parse error and exit with code 1', () => {
      const result = runCli(`--scip ${corruptedScip} Ticket`);

      expect(result.exitCode).toBe(1);
      expect(result.stderr).toMatch(/parse|failed|invalid/i);
    });

    it('should indicate the file could not be parsed', () => {
      const result = runCli(`--scip ${corruptedScip} Ticket`);

      expect(result.stderr).toMatch(/SCIP|file/i);
    });
  });

  // Empty SCIP edge case
  describe('when SCIP file is empty (no documents)', () => {
    const emptyScip = path.join(fixturesDir, 'empty.scip');

    it('should handle gracefully and return no results', () => {
      const result = runCli(`--scip ${emptyScip} Ticket`);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/not found|no results|0 occurrences/i);
    });
  });

  // No symbols edge case
  describe('when SCIP has documents but no symbols', () => {
    const noSymbolsScip = path.join(fixturesDir, 'no-symbols.scip');

    it('should handle gracefully and return no results', () => {
      const result = runCli(`--scip ${noSymbolsScip} Ticket`);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/not found|no results/i);
    });
  });

  // Symbol not found edge case
  describe('when symbol does not exist in SCIP index', () => {
    it('should return "symbol not found" message and exit with code 0', () => {
      const result = runCli('--scip tests/fixtures/index.scip NonexistentSymbol12345');

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/not found/i);
    });

    it('should not throw error for unknown symbol', () => {
      const result = runCli('--scip tests/fixtures/index.scip DefinitelyDoesNotExist');

      expect(result.exitCode).toBe(0);
      expect(result.stderr).toBe('');
    });
  });

  // Requirement 2: Invalid --from file
  describe('when --from file does not contain the symbol', () => {
    it('should show warning and return results from other files', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --from nonexistent/file.ts');

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/warning/i);
    });

    it('should still search all symbols with same name when --from fails', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --from wrong/path.ts');

      expect(result.exitCode).toBe(0);
      // Should have some results or indicate no results
    });
  });

  // Invalid --format value
  describe('when invalid --format value is provided', () => {
    it('should display error with valid options and exit with code 1', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --format xml');

      expect(result.exitCode).toBe(1);
      expect(result.stderr).toMatch(/format/i);
      expect(result.stderr).toMatch(/text|json/i);
    });

    it('should list valid format options in error message', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --format yaml');

      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('text');
      expect(result.stderr).toContain('json');
    });
  });

  // Duplicate symbols edge case
  describe('when SCIP contains duplicate symbols', () => {
    const duplicatesScip = path.join(fixturesDir, 'duplicates.scip');

    it('should handle duplicates without crashing', () => {
      const result = runCli(`--scip ${duplicatesScip} DuplicateSymbol`);

      expect(result.exitCode).toBe(0);
    });

    it('should deduplicate occurrences by position', () => {
      const result = runCli(`--scip ${duplicatesScip} DuplicateSymbol --format json`);

      expect(result.exitCode).toBe(0);

      // Should be able to parse as JSON
      expect(() => JSON.parse(result.stdout)).not.toThrow();
    });
  });

  // Declaration-only symbols edge case
  describe('when symbol only exists in .d.ts declaration file', () => {
    const declarationOnlyScip = path.join(fixturesDir, 'declaration-only.scip');

    it('should return results from declaration file', () => {
      const result = runCli(`--scip ${declarationOnlyScip} OnlyInDeclaration`);

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('.d.ts');
    });
  });

  // Special characters in file paths
  describe('when file paths contain special characters', () => {
    it('should handle spaces in file paths', () => {
      // Test with a path that has spaces
      const result = runCli('--scip tests/fixtures/index.scip Ticket');

      expect(result.exitCode).toBe(0);
    });
  });

  // Overloaded functions edge case
  describe('when symbol has multiple overloads', () => {
    it('should return all overloaded variants', () => {
      const result = runCli('--scip tests/fixtures/index.scip overloadedFunction --format json');

      // Should handle gracefully even if symbol exists
      expect(result.exitCode).toBe(0);
    });
  });

  // Same-named symbols from different packages
  describe('when same-named symbols exist in different packages', () => {
    it('should distinguish them correctly with --from', () => {
      const result1 = runCli('--scip tests/fixtures/index.scip Ticket --from package1/file.ts --format json');
      const result2 = runCli('--scip tests/fixtures/index.scip Ticket --from package2/file.ts --format json');

      expect(result1.exitCode).toBe(0);
      expect(result2.exitCode).toBe(0);
    });
  });

  // Very long symbol names
  describe('when symbol name is extremely long', () => {
    const longSymbolName = 'VeryLongSymbolName'.repeat(10);

    it('should handle long symbol names without error', () => {
      const result = runCli(`--scip tests/fixtures/index.scip ${longSymbolName}`);

      expect(result.exitCode).toBe(0);
    });
  });

  // Empty symbol name
  describe('when symbol name is empty', () => {
    it('should handle empty symbol name gracefully', () => {
      const result = runCli('--scip tests/fixtures/index.scip ""');

      // Should show error or handle gracefully
      expect([0, 1]).toContain(result.exitCode);
    });
  });

  // Folder filtering edge cases
  describe('when --folder path has edge cases', () => {
    it('should handle trailing slash in folder path', () => {
      const result1 = runCli('--scip tests/fixtures/index.scip Ticket --folder src/');
      const result2 = runCli('--scip tests/fixtures/index.scip Ticket --folder src');

      expect(result1.exitCode).toBe(0);
      expect(result2.exitCode).toBe(0);
    });

    it('should handle non-existent folder', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --folder nonexistent/');

      expect(result.exitCode).toBe(0);
      expect(result.stdout).toMatch(/no results|not found/i);
    });

    it('should handle root folder path', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --folder /');

      expect(result.exitCode).toBe(0);
    });
  });

  // Multiple filters combined
  describe('when multiple filters are combined', () => {
    it('should handle --from and --folder together', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --from file.ts --folder src/');

      expect(result.exitCode).toBe(0);
    });
  });

  // Output format edge cases
  describe('when output format has edge cases', () => {
    it('should handle empty results in text format', () => {
      const result = runCli('--scip tests/fixtures/empty.scip Ticket --format text');

      expect(result.exitCode).toBe(0);
    });

    it('should handle empty results in JSON format', () => {
      const result = runCli('--scip tests/fixtures/empty.scip Ticket --format json');

      expect(result.exitCode).toBe(0);

      // Should parse as valid JSON even with empty results
      expect(() => JSON.parse(result.stdout)).not.toThrow();
    });

    it('should include all required fields in JSON output even for edge cases', () => {
      const result = runCli('--scip tests/fixtures/empty.scip Ticket --format json');

      expect(result.exitCode).toBe(0);

      const json = JSON.parse(result.stdout);
      expect(json).toHaveProperty('symbol');
      expect(json).toHaveProperty('occurrences');
      expect(Array.isArray(json.occurrences)).toBe(true);
    });
  });

  // Performance edge cases
  describe('when SCIP file is very large', () => {
    it('should load and index without timing out', () => {
      const start = Date.now();
      const result = runCli('--scip tests/fixtures/index.scip Ticket');
      const duration = Date.now() - start;

      expect(result.exitCode).toBe(0);
      // Should complete in reasonable time (10 seconds max for CI environments)
      expect(duration).toBeLessThan(10000);
    });
  });

  // Symbol role edge cases
  describe('when symbol role has edge cases', () => {
    it('should handle unknown/invalid role bitmask', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --format json');

      expect(result.exitCode).toBe(0);

      const json = JSON.parse(result.stdout);
      if (json.occurrences.length > 0) {
        // All occurrences should have a role field
        json.occurrences.forEach((occ: any) => {
          expect(occ).toHaveProperty('role');
          expect(typeof occ.role).toBe('string');
        });
      }
    });

    it('should handle symbols with multiple roles', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --format json');

      expect(result.exitCode).toBe(0);

      const json = JSON.parse(result.stdout);
      if (json.occurrences.length > 0) {
        // Check boolean flags
        json.occurrences.forEach((occ: any) => {
          expect(typeof occ.isDefinition).toBe('boolean');
          expect(typeof occ.isReference).toBe('boolean');
          expect(typeof occ.isImport).toBe('boolean');
          expect(typeof occ.isExport).toBe('boolean');
        });
      }
    });
  });
});

describe('Phase 4: Error Message Quality', () => {
  // Note: runCli is imported from shared helper at top of file

  describe('error messages should be actionable', () => {
    it('should suggest --scip when SCIP file not found', () => {
      const result = runCli('Ticket');
      expect(result.stderr).toContain('--scip');
    });

    it('should suggest valid formats when format is invalid', () => {
      const result = runCli('--scip tests/fixtures/index.scip Ticket --format invalid');
      expect(result.stderr).toMatch(/text|json/i);
    });

    it('should show file path when SCIP file is missing', () => {
      const result = runCli('--scip /missing/index.scip Ticket');
      expect(result.stderr).toContain('/missing/index.scip');
    });
  });

  describe('error messages should be clear', () => {
    it('should clearly indicate SCIP file not found', () => {
      const result = runCli('--scip /nonexistent.scip Ticket');
      expect(result.stderr).toMatch(/not found|SCIP/i);
    });

    it('should clearly indicate parse error for corrupted SCIP', () => {
      const result = runCli('--scip tests/fixtures/edge-cases/corrupted.scip Ticket');
      expect(result.stderr).toMatch(/parse|failed|invalid/i);
    });
  });
});
