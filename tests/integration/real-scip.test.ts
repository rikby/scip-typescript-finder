/**
 * Tests for: SCF-001 Phase 3
 * Phase: CLI + Output + Integration Tests (Real SCIP validation)
 * Requirements: R1, R2, R3, R4, R5, R6, R7, R10
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

describe('Real SCIP Integration Tests', () => {
  const cliPath = path.join(process.cwd(), 'dist/src/cli.js');
  // Path to the markdown-ticket project SCIP file
  const realScipPath = path.join(process.cwd(), 'markdown-ticket/index.scip');

  const runCli = (args: string): { stdout: string; stderr: string; exitCode: number } => {
    try {
      // Use shell redirection to capture both stdout and stderr
      const stdout = execSync(`node ${cliPath} ${args} 2>&1`, {
        encoding: 'utf-8'
      });
      // With redirection 2>&1, stderr goes to stdout in the result
      // We can't easily separate them, so put everything in stdout
      return { stdout, stderr: '', exitCode: 0 };
    } catch (error: any) {
      return {
        stdout: error.stdout?.toString() || '',
        stderr: error.stderr?.toString() || error.message,
        exitCode: error.status || 1
      };
    }
  };

  // Skip all tests if real SCIP file doesn't exist
  beforeAll(() => {
    if (!fs.existsSync(realScipPath)) {
      console.warn(`\nReal SCIP file not found at ${realScipPath}`);
      console.warn('Skipping real SCIP integration tests.');
      console.warn('Generate SCIP file with: scip-typescript index --projectName markdown-ticket\n');
    }
  });

  // Phase 3 - Real-world validation for R1: Symbol Search by Name
  describe('Real SCIP - Symbol Search (R1)', () => {
    describe('when searching for Ticket interface', () => {
      it('should find all usages across the project', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket`);
        expect(result.exitCode).toBe(0);
        expect(result.stdout.length).toBeGreaterThan(0);
      });
    });

    describe('when searching for function/method', () => {
      it('should find all usages of the function', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} parseDate`);
        expect(result.exitCode).toBe(0);
      });
    });
  });

  // Phase 3 - Real-world validation for R2: Definition File Filtering
  describe('Real SCIP - Definition File Filtering (R2)', () => {
    describe('when searching for Ticket with --from shared/models/Ticket.ts', () => {
      it('should return only usages of Ticket from that specific file', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --from shared/models/Ticket.ts`);
        expect(result.exitCode).toBe(0);

        // Parse JSON to verify results
        const jsonResult = runCli(`--scip ${realScipPath} Ticket --from shared/models/Ticket.ts --format json`);
        const data = JSON.parse(jsonResult.stdout);

        // All results should be from the correct package
        if (data.occurrences.length > 0) {
          data.occurrences.forEach((occ: any) => {
            expect(occ.file).toBeDefined();
          });
        }
      });
    });

    describe('when --from file does not contain the symbol', () => {
      it('should show warning and return results from other files', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --from nonexistent/file.ts`);
        // Should still complete but show warning
        expect(result.exitCode).toBe(0);
        // Warning is now in stdout due to 2>&1 redirection
        expect(result.stdout).toMatch(/warning/i);
        // Should also have results from other files
        expect(result.stdout).toContain('src/');
      });
    });
  });

  // Phase 3 - Real-world validation for R3: Folder Scope Filtering
  describe('Real SCIP - Folder Scope Filtering (R3)', () => {
    describe('when searching for Ticket with --folder shared/', () => {
      it('should return only occurrences in shared folder', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --folder shared/`);
        expect(result.exitCode).toBe(0);

        // Verify folder filtering in JSON output
        const jsonResult = runCli(`--scip ${realScipPath} Ticket --folder shared/ --format json`);
        const data = JSON.parse(jsonResult.stdout);

        if (data.occurrences.length > 0) {
          data.occurrences.forEach((occ: any) => {
            expect(occ.file).toMatch(/shared/);
          });
        }
      });
    });

    describe('when searching for Ticket with --folder src/', () => {
      it('should return only occurrences in src folder', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --folder src/`);
        expect(result.exitCode).toBe(0);

        const jsonResult = runCli(`--scip ${realScipPath} Ticket --folder src/ --format json`);
        const data = JSON.parse(jsonResult.stdout);

        if (data.occurrences.length > 0) {
          data.occurrences.forEach((occ: any) => {
            expect(occ.file).toMatch(/src/);
          });
        }
      });
    });
  });

  // Phase 3 - Real-world validation for R4: Package-Aware Distinction
  describe('Real SCIP - Package-Aware Distinction (R4)', () => {
    describe('when same-named symbols exist in different packages', () => {
      it('should distinguish between them based on package', () => {
        if (!fs.existsSync(realScipPath)) return;
        // Search for Ticket (which exists in multiple packages)
        const result1 = runCli(`--scip ${realScipPath} Ticket --from shared/models/Ticket.ts --format json`);
        const result2 = runCli(`--scip ${realScipPath} Ticket --from src/types/ticket.ts --format json`);

        expect(result1.exitCode).toBe(0);
        expect(result2.exitCode).toBe(0);

        const data1 = JSON.parse(result1.stdout);
        const data2 = JSON.parse(result2.stdout);

        // Results should be from different packages/files
        if (data1.occurrences.length > 0 && data2.occurrences.length > 0) {
          const pkg1 = data1.occurrences[0].package;
          const pkg2 = data2.occurrences[0].package;
          // Should be different or have different file paths
          expect(pkg1 || data1.occurrences[0].file).not.toBe(pkg2 || data2.occurrences[0].file);
        }
      });
    });
  });

  // Phase 3 - Real-world validation for R5: Declaration File Handling
  describe('Real SCIP - Declaration File Handling (R5)', () => {
    describe('when symbol has both .ts and .d.ts variants', () => {
      it('should merge occurrences from both variants', () => {
        if (!fs.existsSync(realScipPath)) return;
        // This tests that .d.ts files are handled correctly
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);
        // Should have occurrences from both .ts and .d.ts if they exist
        if (data.occurrences.length > 0) {
          const hasTsFile = data.occurrences.some((occ: any) => occ.file.endsWith('.ts'));
          const hasDtsFile = data.occurrences.some((occ: any) => occ.file.endsWith('.d.ts'));

          // At least one should be true
          expect(hasTsFile || hasDtsFile).toBe(true);
        }
      });
    });
  });

  // Phase 3 - Real-world validation for R6, R7: Output Formats
  describe('Real SCIP - Output Format Validation (R6, R7)', () => {
    describe('text format', () => {
      it('should produce grep-like output with correct format', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --format text`);
        expect(result.exitCode).toBe(0);

        const lines = result.stdout.trim().split('\n');
        if (lines.length > 0 && lines[0]) {
          // Each line should match: file:line:column: role
          expect(lines[0]).toMatch(/^.+:\d+:\d+:/);
        }
      });
    });

    describe('json format', () => {
      it('should produce valid JSON with all required fields', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);

        // Verify top-level structure
        expect(data).toHaveProperty('symbol');
        expect(data).toHaveProperty('occurrences');
        expect(Array.isArray(data.occurrences)).toBe(true);

        // Verify occurrence structure
        if (data.occurrences.length > 0) {
          const occ = data.occurrences[0];
          expect(occ).toHaveProperty('file');
          expect(occ).toHaveProperty('line');
          expect(occ).toHaveProperty('column');
          expect(occ).toHaveProperty('role');
          expect(occ).toHaveProperty('isDefinition');
          expect(occ).toHaveProperty('isReference');
          expect(occ).toHaveProperty('isImport');
          expect(occ).toHaveProperty('isExport');
        }
      });
    });
  });

  // Phase 3 - Real-world validation for R10: Symbol Role Identification
  describe('Real SCIP - Symbol Role Identification (R10)', () => {
    describe('when symbol has multiple roles', () => {
      it('should display all applicable role names', () => {
        if (!fs.existsSync(realScipPath)) return;
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);

        if (data.occurrences.length > 0) {
          // Check for different roles
          const roles = new Set(data.occurrences.map((occ: any) => occ.role));
          expect(roles.size).toBeGreaterThan(0);

          // Common roles should be present
          const allRoles = Array.from(roles).join(', ');
          expect(allRoles).toBeDefined();
        }
      });
    });

    describe('when role cannot be determined', () => {
      it('should display Unknown role', () => {
        if (!fs.existsSync(realScipPath)) return;
        // This test ensures unknown bitmasks are handled
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);

        // All occurrences should have a role (even if Unknown)
        data.occurrences.forEach((occ: any) => {
          expect(occ.role).toBeDefined();
          expect(typeof occ.role).toBe('string');
        });
      });
    });
  });

  // Phase 3 - Cross-package verification
  describe('Real SCIP - Cross-Package Symbol Search', () => {
    describe('when symbol is used across multiple packages', () => {
      it('should find all usages in shared, src, server, mcp-server, domain-contracts', () => {
        if (!fs.existsSync(realScipPath)) return;

        // Test Ticket symbol which should be in multiple packages
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);

        if (data.occurrences.length > 0) {
          // Group by package/folder
          const folders = new Set(data.occurrences.map((occ: any) => {
            const match = occ.file.match(/^([^/]+)/);
            return match ? match[1] : 'other';
          }));

          // Should have multiple folders
          expect(folders.size).toBeGreaterThanOrEqual(1);
        }
      });
    });

    describe('when searching with --from in domain-contracts package', () => {
      it('should find only symbols from that package', () => {
        if (!fs.existsSync(realScipPath)) return;

        const result = runCli(`--scip ${realScipPath} Ticket --from domain-contracts --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);

        if (data.occurrences.length > 0) {
          data.occurrences.forEach((occ: any) => {
            expect(occ.file).toMatch(/domain-contracts/);
          });
        }
      });
    });
  });

  // Phase 3 - Performance validation
  describe('Real SCIP - Performance', () => {
    describe('when searching for commonly used symbols', () => {
      it('should complete query in reasonable time', () => {
        if (!fs.existsSync(realScipPath)) return;

        const start = Date.now();
        const result = runCli(`--scip ${realScipPath} Ticket`);
        const duration = Date.now() - start;

        expect(result.exitCode).toBe(0);
        // Should be very fast (< 1 second for query)
        expect(duration).toBeLessThan(1000);
      });
    });
  });

  // Phase 3 - Edge cases from real SCIP
  describe('Real SCIP - Edge Cases', () => {
    describe('when searching for overloaded functions', () => {
      it('should return all overloaded variants', () => {
        if (!fs.existsSync(realScipPath)) return;

        // Many functions might have overloads
        const result = runCli(`--scip ${realScipPath} config --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);
        // Should handle multiple definitions
        expect(data.occurrences).toBeInstanceOf(Array);
      });
    });

    describe('when symbol name matches multiple symbols', () => {
      it('should return all matching symbols without --from', () => {
        if (!fs.existsSync(realScipPath)) return;

        // Ticket exists in multiple packages
        const result = runCli(`--scip ${realScipPath} Ticket --format json`);
        expect(result.exitCode).toBe(0);

        const data = JSON.parse(result.stdout);
        // Should have results from multiple files
        if (data.occurrences.length > 0) {
          const files = new Set(data.occurrences.map((occ: any) => occ.file));
          expect(files.size).toBeGreaterThanOrEqual(1);
        }
      });
    });
  });
});
