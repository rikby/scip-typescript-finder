/**
 * Tests for: SCF-001 Phase 1
 * Phase: 1 - Foundation (Symbol Indexer)
 * Requirements: R1 (Symbol Search), R4 (Package-Aware Distinction), R5 (Declaration File Handling)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import { buildSymbolIndex, mergeSymbolVariants } from '../../../src/core/symbol-indexer';

// Mock SCIP data structures
const mockScipIndex = {
  documents: [
    {
      relativePath: 'src/models/Ticket.ts',
      symbols: [
        {
          symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
          documentation: [],
          kind: 1, // Interface
          displayName: 'Ticket'
        }
      ],
      occurrences: [
        {
          symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
          range: [5, 0, 5, 6],
          symbolRoles: 1, // Definition
          syntaxKind: 0
        },
        {
          symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
          range: [10, 10, 10, 16],
          symbolRoles: 2, // Reference
          syntaxKind: 0
        }
      ]
    },
    {
      relativePath: 'src/types/Ticket.ts',
      symbols: [
        {
          symbol: 'scip-typescript npm markdown-ticket 0.0.0 types/\\`Ticket.ts\\`/Ticket#',
          documentation: [],
          kind: 1,
          displayName: 'Ticket'
        }
      ],
      occurrences: [
        {
          symbol: 'scip-typescript npm markdown-ticket 0.0.0 types/\\`Ticket.ts\\`/Ticket#',
          range: [3, 0, 3, 6],
          symbolRoles: 1,
          syntaxKind: 0
        }
      ]
    },
    {
      relativePath: 'models/Ticket.d.ts',
      symbols: [
        {
          symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.d.ts\\`/Ticket#',
          documentation: [],
          kind: 1,
          displayName: 'Ticket'
        }
      ],
      occurrences: [
        {
          symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.d.ts\\`/Ticket#',
          range: [1, 0, 1, 6],
          symbolRoles: 1,
          syntaxKind: 0
        }
      ]
    }
  ],
  metadata: {
    toolInfo: { name: 'scip-typescript', version: '0.4.0' }
  }
};

describe('Symbol Indexer', () => {
  describe('buildSymbolIndex', () => {
    // @phase:1 @requirement:R1
    describe('when building index from SCIP data', () => {
      it('should create Map with symbol keys to occurrences arrays', () => {
        const index = buildSymbolIndex(mockScipIndex);

        expect(index).toBeInstanceOf(Map);
        expect(index.size).toBeGreaterThan(0);
      });

      it('should index all unique symbols from SCIP documents', () => {
        const index = buildSymbolIndex(mockScipIndex);

        // Should have 2 unique Ticket symbols (different packages)
        // The .d.ts variant should be merged with .ts variant
        expect(index.size).toBe(2);
      });

      it('should store occurrences as arrays for each symbol', () => {
        const index = buildSymbolIndex(mockScipIndex);

        index.forEach((occurrences) => {
          expect(Array.isArray(occurrences)).toBe(true);
        });
      });
    });

    // @phase:1 @requirement:R4
    describe('when indexing symbols with same name from different packages', () => {
      it('should create separate entries for each package', () => {
        const index = buildSymbolIndex(mockScipIndex);

        const package1Key = '@mdt/shared:models/Ticket.ts:Ticket';
        const package2Key = 'markdown-ticket:types/Ticket.ts:Ticket';

        expect(index.has(package1Key)).toBe(true);
        expect(index.has(package2Key)).toBe(true);
        expect(index.get(package1Key)).not.toBe(index.get(package2Key));
      });
    });

    // @phase:1 @requirement:R5
    describe('when indexing .ts and .d.ts variants of same symbol', () => {
      it('should merge occurrences from both variants', () => {
        const index = buildSymbolIndex(mockScipIndex);

        const mergedKey = '@mdt/shared:models/Ticket.ts:Ticket';
        const occurrences = index.get(mergedKey);

        // Should have occurrences from both .ts and .d.ts files
        expect(occurrences).toBeDefined();
        expect(occurrences?.length).toBeGreaterThan(1);

        // Check that we have occurrences from different files
        const filePaths = new Set(occurrences!.map(occ => occ.filePath));
        expect(filePaths.size).toBeGreaterThanOrEqual(1);
      });

      it('should normalize .d.ts file paths to .ts in key', () => {
        const index = buildSymbolIndex(mockScipIndex);

        // The key should use .ts, not .d.ts
        const normalizedKey = '@mdt/shared:models/Ticket.ts:Ticket';
        expect(index.has(normalizedKey)).toBe(true);
      });
    });

    // @phase:1 @requirement:R5
    describe('when deduplicating occurrences', () => {
      it('should remove duplicate occurrences by file and position', () => {
        const duplicateScipData = {
          ...mockScipIndex,
          documents: [
            {
              relativePath: 'src/models/Ticket.ts',
              symbols: mockScipIndex.documents[0].symbols,
              occurrences: [
                // Same occurrence twice
                ...mockScipIndex.documents[0].occurrences!,
                ...mockScipIndex.documents[0].occurrences!
              ]
            }
          ]
        };

        const index = buildSymbolIndex(duplicateScipData);
        const key = '@mdt/shared:models/Ticket.ts:Ticket';
        const occurrences = index.get(key);

        // Should deduplicate to 2 unique occurrences
        expect(occurrences?.length).toBe(2);
      });
    });
  });

  describe('mergeSymbolVariants', () => {
    // @phase:1 @requirement:R5
    describe('when merging .ts and .d.ts symbol occurrences', () => {
      it('should combine occurrences from both variants', () => {
        const tsOccurrences = [
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
            filePath: 'src/models/Ticket.ts',
            line: 5,
            column: 0,
            endLine: 5,
            endColumn: 6,
            roles: 1
          },
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
            filePath: 'src/models/Ticket.ts',
            line: 10,
            column: 10,
            endLine: 10,
            endColumn: 16,
            roles: 2
          }
        ];

        const dtsOccurrences = [
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.d.ts\\`/Ticket#',
            filePath: 'models/Ticket.d.ts',
            line: 1,
            column: 0,
            endLine: 1,
            endColumn: 6,
            roles: 1
          }
        ];

        const merged = mergeSymbolVariants(tsOccurrences, dtsOccurrences);

        expect(merged).toHaveLength(3);
      });

      it('should deduplicate by file path and position', () => {
        const tsOccurrences = [
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
            filePath: 'src/models/Ticket.ts',
            line: 5,
            column: 0,
            endLine: 5,
            endColumn: 6,
            roles: 1
          }
        ];

        const dtsOccurrences = [
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
            filePath: 'src/models/Ticket.ts',
            line: 5,
            column: 0,
            endLine: 5,
            endColumn: 6,
            roles: 1
          }
        ];

        const merged = mergeSymbolVariants(tsOccurrences, dtsOccurrences);

        expect(merged).toHaveLength(1);
      });
    });

    // @phase:1 @requirement:R5
    describe('when only .d.ts variant exists', () => {
      it('should return .d.ts occurrences unchanged', () => {
        const dtsOccurrences = [
          {
            symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.d.ts\\`/Ticket#',
            filePath: 'models/Ticket.d.ts',
            line: 1,
            column: 0,
            endLine: 1,
            endColumn: 6,
            roles: 1
          }
        ];

        const merged = mergeSymbolVariants([], dtsOccurrences);

        expect(merged).toEqual(dtsOccurrences);
      });
    });
  });

  describe('Index Structure', () => {
    // @phase:1
    describe('when querying the index', () => {
      it('should support O(1) lookup by symbol key', () => {
        const index = buildSymbolIndex(mockScipIndex);

        const key = '@mdt/shared:models/Ticket.ts:Ticket';
        const startTime = performance.now();
        const occurrences = index.get(key);
        const endTime = performance.now();

        expect(occurrences).toBeDefined();
        expect(endTime - startTime).toBeLessThan(1); // Sub-millisecond lookup
      });

      it('should return undefined for non-existent symbols', () => {
        const index = buildSymbolIndex(mockScipIndex);

        expect(index.get('nonexistent:file.ts:Symbol')).toBeUndefined();
      });
    });
  });
});
