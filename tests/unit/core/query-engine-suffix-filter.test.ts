/**
 * Tests for: SCF-004 Phase 2
 * Phase: 2 - Suffix-Aware Query Filtering
 * Requirements: R2 (Suffix-Aware Filtering), R4 (Backward Compatibility)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import { QueryEngine } from '../../../src/core/query-engine';
import { SuffixType } from '../../../src/core/scip/SuffixType';

// Mock symbol index structure with suffix-aware keys
const createMockSymbolIndex = () => {
  const index = new Map();

  // MyThing.type# - Type suffix
  index.set('@mdt/shared:models/MyThing.ts:MyThing', [
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/MyThing#',
      filePath: 'models/MyThing.ts',
      line: 5,
      column: 0,
      roles: 1, // Definition
      isDefinition: true,
      suffix: SuffixType.Type
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/MyThing#',
      filePath: 'src/factory.ts',
      line: 10,
      column: 15,
      roles: 2, // Reference
      isDefinition: false,
      suffix: SuffixType.Type
    }
  ]);

  // MyThing.myProp. - Property (Term) suffix
  index.set('@mdt/shared:models/MyThing.ts:myProp', [
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/myProp.',
      filePath: 'models/MyThing.ts',
      line: 12,
      column: 2,
      roles: 1, // Definition
      isDefinition: true,
      suffix: SuffixType.Term
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/myProp.',
      filePath: 'src/consumer.ts',
      line: 8,
      column: 10,
      roles: 2, // Reference
      isDefinition: false,
      suffix: SuffixType.Term
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/myProp.',
      filePath: 'tests/MyThing.test.ts',
      line: 15,
      column: 20,
      roles: 2, // Reference
      isDefinition: false,
      suffix: SuffixType.Term
    }
  ]);

  // MyThing.process(). - Method suffix
  index.set('@mdt/shared:models/MyThing.ts:process', [
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/process().',
      filePath: 'models/MyThing.ts',
      line: 18,
      column: 2,
      roles: 1, // Definition
      isDefinition: true,
      suffix: SuffixType.Method
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`MyThing.ts\\`/process().',
      filePath: 'src/caller.ts',
      line: 5,
      column: 12,
      roles: 2, // Reference
      isDefinition: false,
      suffix: SuffixType.Method
    }
  ]);

  // Another class with same property name
  index.set('other-package:models/Other.ts:myProp', [
    {
      symbol: 'scip-typescript npm other-package 1.0.0 models/\\`Other.ts\\`/myProp.',
      filePath: 'models/Other.ts',
      line: 3,
      column: 0,
      roles: 1,
      isDefinition: true,
      suffix: SuffixType.Term
    }
  ]);

  return index;
};

describe('Query Engine - Suffix Filtering', () => {
  let queryEngine: QueryEngine;
  let mockIndex: Map<string, any[]>;

  beforeEach(() => {
    mockIndex = createMockSymbolIndex();
    queryEngine = new QueryEngine(mockIndex);
  });

  // @requirement:R2.1
  describe('when filtering by property suffix', () => {
    it('should return only property occurrences', () => {
      const results = queryEngine.find('myProp', {
        suffixFilter: SuffixType.Term
      });

      // Should find 4 property occurrences (3 from MyThing, 1 from Other)
      expect(results).toHaveLength(4);
      results.forEach(result => {
        expect(result.suffix).toBe(SuffixType.Term);
      });
    });

    it('should exclude methods and types when filtering for properties', () => {
      const results = queryEngine.find('myProp', {
        suffixFilter: SuffixType.Term
      });

      // All results should be properties
      const hasNonProperty = results.some(r => r.suffix !== SuffixType.Term);
      expect(hasNonProperty).toBe(false);
    });
  });

  // @requirement:R2.2
  describe('when filtering by method suffix', () => {
    it('should return only method occurrences', () => {
      const results = queryEngine.find('process', {
        suffixFilter: SuffixType.Method
      });

      // Should find 2 method occurrences
      expect(results).toHaveLength(2);
      results.forEach(result => {
        expect(result.suffix).toBe(SuffixType.Method);
      });
    });

    it('should exclude properties and types when filtering for methods', () => {
      const results = queryEngine.find('process', {
        suffixFilter: SuffixType.Method
      });

      const hasNonMethod = results.some(r => r.suffix !== SuffixType.Method);
      expect(hasNonMethod).toBe(false);
    });
  });

  // @requirement:R2.3
  describe('when no suffix filter is provided (wildcard)', () => {
    it('should return all occurrences regardless of suffix type', () => {
      const results = queryEngine.find('myProp');

      // Should find all 4 occurrences (all are properties in this case)
      expect(results).toHaveLength(4);
    });

    it('should return mixed suffix types when symbol exists as multiple types', () => {
      // Add a symbol that exists as both property and method
      mockIndex.set('test:Test.ts:handle', [
        {
          symbol: 'scip-typescript npm test 1.0.0 test/\\`Test.ts\\`/handle.',
          filePath: 'test/Test.ts',
          line: 1,
          column: 0,
          roles: 1,
          isDefinition: true,
          suffix: SuffixType.Term
        },
        {
          symbol: 'scip-typescript npm test 1.0.0 test/\\`Test.ts\\`/handle().',
          filePath: 'test/Test.ts',
          line: 2,
          column: 0,
          roles: 1,
          isDefinition: true,
          suffix: SuffixType.Method
        }
      ]);

      const results = queryEngine.find('handle');

      // Should return both property and method
      expect(results.length).toBeGreaterThanOrEqual(2);
      const suffixes = new Set(results.map(r => r.suffix));
      expect(suffixes).toContain(SuffixType.Term);
      expect(suffixes).toContain(SuffixType.Method);
    });
  });

  // @requirement:R2.4
  describe('when filtering occurs at index level', () => {
    it('should filter during lookup, not post-process', () => {
      // This test verifies the architectural requirement that filtering
      // happens at index level for efficiency
      const results = queryEngine.find('myProp', {
        suffixFilter: SuffixType.Term
      });

      // Results should already be filtered
      expect(results.every(r => r.suffix === SuffixType.Term)).toBe(true);
    });

    it('should handle combined filters efficiently', () => {
      const results = queryEngine.find('myProp', {
        from: 'models/MyThing.ts',
        suffixFilter: SuffixType.Term
      });

      // Correct behavior: from selects symbol (3 occurrences), suffix filters all
      // Should apply both filters correctly
      expect(results).toHaveLength(3);
      expect(results.every(r => r.suffix === SuffixType.Term)).toBe(true);
    });
  });

  // @requirement:R4.2
  describe('backward compatibility - wildcard default', () => {
    it('should default to wildcard when suffixFilter is undefined', () => {
      const wildcardResults = queryEngine.find('myProp');
      const explicitResults = queryEngine.find('myProp', {});

      expect(wildcardResults).toEqual(explicitResults);
    });

    it('should maintain existing behavior for queries without suffix awareness', () => {
      // Existing behavior: return all symbol occurrences
      const results = queryEngine.find('MyThing');

      // Should include type definition
      expect(results.some(r => r.suffix === SuffixType.Type)).toBe(true);
    });
  });

  // @requirement:R5.4
  describe('edge case - SCIP index missing suffix', () => {
    it('should gracefully handle occurrences without suffix field', () => {
      // Add legacy index entry without suffix
      mockIndex.set('legacy:Legacy.ts:oldSymbol', [
        {
          symbol: 'scip-typescript npm legacy 1.0.0 legacy/\\`Legacy.ts\\`/oldSymbol#',
          filePath: 'legacy/Legacy.ts',
          line: 1,
          column: 0,
          roles: 1,
          isDefinition: true
          // No suffix field
        }
      ]);

      // Should still return results (graceful degradation)
      const results = queryEngine.find('oldSymbol');
      expect(results.length).toBeGreaterThan(0);
    });
  });

  describe('suffix filtering with other options', () => {
    it('should combine suffixFilter with from option', () => {
      const results = queryEngine.find('myProp', {
        from: 'models/MyThing.ts',
        suffixFilter: SuffixType.Term
      });

      // Correct behavior: from option selects the symbol defined in models/MyThing.ts
      // and returns ALL its occurrences (3 total: 1 def + 2 refs), filtered by suffix
      expect(results).toHaveLength(3);
      expect(results.every(r => r.suffix === SuffixType.Term)).toBe(true);

      // Should include definition from models/MyThing.ts
      const definition = results.find(r => r.isDefinition);
      expect(definition?.filePath).toBe('models/MyThing.ts');

      // Should include references from other files
      const references = results.filter(r => !r.isDefinition);
      expect(references.length).toBe(2);
      expect(references.some(r => r.filePath === 'src/consumer.ts')).toBe(true);
      expect(references.some(r => r.filePath === 'tests/MyThing.test.ts')).toBe(true);
    });

    it('should combine suffixFilter with folder option', () => {
      const results = queryEngine.find('myProp', {
        folder: 'src/',
        suffixFilter: SuffixType.Term
      });

      expect(results.length).toBeGreaterThan(0);
      results.forEach(result => {
        expect(result.filePath).toMatch(/^src\//);
        expect(result.suffix).toBe(SuffixType.Term);
      });
    });

    it('should combine all three filters together', () => {
      const results = queryEngine.find('myProp', {
        from: 'models/MyThing.ts',
        folder: 'models/',
        suffixFilter: SuffixType.Term
      });

      // Correct behavior:
      // 1. from selects symbol defined in models/MyThing.ts (all 3 occurrences)
      // 2. folder filters to only those in models/ folder (1 definition)
      // 3. suffixFilter ensures it's a property (Term suffix)
      expect(results).toHaveLength(1);
      expect(results[0].filePath).toBe('models/MyThing.ts');
      expect(results[0].suffix).toBe(SuffixType.Term);
      expect(results[0].isDefinition).toBe(true);
    });
  });

  describe('edge cases for suffix filtering', () => {
    it('should handle empty results gracefully', () => {
      const results = queryEngine.find('nonexistent', {
        suffixFilter: SuffixType.Method
      });

      expect(results).toEqual([]);
    });

    it('should handle type suffix filtering', () => {
      const results = queryEngine.find('MyThing', {
        suffixFilter: SuffixType.Type
      });

      expect(results.length).toBeGreaterThan(0);
      results.forEach(result => {
        expect(result.suffix).toBe(SuffixType.Type);
      });
    });

    it('should handle namespace suffix filtering', () => {
      mockIndex.set('test:Test.ts:MyNamespace', [
        {
          symbol: 'scip-typescript npm test 1.0.0 test/\\`Test.ts\\`/MyNamespace/',
          filePath: 'test/Test.ts',
          line: 1,
          column: 0,
          roles: 1,
          isDefinition: true,
          suffix: SuffixType.Namespace
        }
      ]);

      const results = queryEngine.find('MyNamespace', {
        suffixFilter: SuffixType.Namespace
      });

      expect(results.length).toBeGreaterThan(0);
      results.forEach(result => {
        expect(result.suffix).toBe(SuffixType.Namespace);
      });
    });
  });
});
