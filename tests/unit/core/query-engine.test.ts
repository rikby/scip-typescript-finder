/**
 * Tests for: SCF-001 Phase 2
 * Phase: 2 - Query Core (Symbol Lookup with Filtering)
 * Requirements: R1 (Symbol Search), R2 (Definition File Filtering), R3 (Folder Scope Filtering), R4 (Package-Aware Distinction)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import { QueryEngine } from '../../../src/core/query-engine';

// Mock symbol index structure
const createMockSymbolIndex = () => {
  const index = new Map();

  // @mdt/shared package - Ticket from shared/models/Ticket.ts
  index.set('@mdt/shared:models/Ticket.ts:Ticket', [
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
      filePath: 'shared/models/Ticket.ts',
      line: 5,
      column: 0,
      roles: 1, // Definition
      isDefinition: true
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
      filePath: 'shared/models/Ticket.ts',
      line: 15,
      column: 10,
      roles: 2, // Reference
      isDefinition: false
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
      filePath: 'src/TicketService.ts',
      line: 8,
      column: 15,
      roles: 4, // Import
      isDefinition: false
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#',
      filePath: 'server/handlers.ts',
      line: 12,
      column: 20,
      roles: 2, // Reference
      isDefinition: false
    }
  ]);

  // markdown-ticket package - Ticket from src/types.ts
  index.set('markdown-ticket:types/Ticket.ts:Ticket', [
    {
      symbol: 'scip-typescript npm markdown-ticket 0.0.0 types/\\`Ticket.ts\\`/Ticket#',
      filePath: 'src/types.ts',
      line: 10,
      column: 0,
      roles: 1, // Definition
      isDefinition: true
    },
    {
      symbol: 'scip-typescript npm markdown-ticket 0.0.0 types/\\`Ticket.ts\\`/Ticket#',
      filePath: 'src/utils.ts',
      line: 5,
      column: 8,
      roles: 2, // Reference
      isDefinition: false
    }
  ]);

  // Another symbol in @mdt/shared
  index.set('@mdt/shared:models/User.ts:User', [
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`User.ts\\`/User#',
      filePath: 'shared/models/User.ts',
      line: 3,
      column: 0,
      roles: 1,
      isDefinition: true
    },
    {
      symbol: 'scip-typescript npm @mdt/shared 1.0.0 models/\\`User.ts\\`/User#',
      filePath: 'src/auth.ts',
      line: 7,
      column: 12,
      roles: 4,
      isDefinition: false
    }
  ]);

  return index;
};

describe('Query Engine', () => {
  let queryEngine: QueryEngine;
  let mockIndex: Map<string, any[]>;

  beforeEach(() => {
    mockIndex = createMockSymbolIndex();
    queryEngine = new QueryEngine(mockIndex);
  });

  // @phase:2 @requirement:R1
  describe('Symbol Search by Name (R1)', () => {
    describe('when searching for symbol by simple name', () => {
      it('should return all occurrences of symbols matching the name', () => {
        const results = queryEngine.find('Ticket');

        // Should find Tickets from both packages
        expect(results.length).toBeGreaterThan(0);
        expect(results).toHaveLength(6); // 4 from @mdt/shared + 2 from markdown-ticket
      });

      it('should return results with expected structure', () => {
        const results = queryEngine.find('Ticket');

        results.forEach(result => {
          expect(result).toHaveProperty('symbol');
          expect(result).toHaveProperty('filePath');
          expect(result).toHaveProperty('line');
          expect(result).toHaveProperty('column');
          expect(result).toHaveProperty('roles');
        });
      });

      it('should return empty array for unknown symbol', () => {
        const results = queryEngine.find('NonExistent');

        expect(results).toEqual([]);
      });
    });

    describe('when searching with case-sensitive name', () => {
      it('should not match symbols with different casing', () => {
        const upperResults = queryEngine.find('Ticket');
        const lowerResults = queryEngine.find('ticket');

        expect(upperResults.length).toBeGreaterThan(0);
        expect(lowerResults).toEqual([]);
      });
    });
  });

  // @phase:2 @requirement:R2
  describe('Definition File Filtering (R2)', () => {
    describe('when --from option specifies a defining file', () => {
      it('should return only occurrences from symbols defined in that file', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        // Should only return the 4 occurrences from @mdt/shared Ticket
        expect(results).toHaveLength(4);
        results.forEach(result => {
          expect(result.symbol).toContain('@mdt/shared');
          expect(result.symbol).not.toContain('markdown-ticket');
        });
      });

      it('should work with relative file path', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        expect(results).toHaveLength(4);
      });

      it('should work with different file paths for same-named symbols', () => {
        const results1 = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });
        const results2 = queryEngine.find('Ticket', {
          from: 'src/types.ts'
        });

        // Different results for different defining files
        expect(results1).not.toEqual(results2);
        expect(results1).toHaveLength(4);
        expect(results2).toHaveLength(2);
      });
    });

    describe('when --from file does not contain the symbol definition', () => {
      it('should return empty results', () => {
        const results = queryEngine.find('Ticket', {
          from: 'some/other/File.ts'
        });

        expect(results).toEqual([]);
      });

      it('should handle non-existent file gracefully', () => {
        const results = queryEngine.find('Ticket', {
          from: 'nonexistent/file.ts'
        });

        expect(results).toEqual([]);
      });
    });

    describe('when --from option is not provided', () => {
      it('should return all symbols matching the name across all packages', () => {
        const results = queryEngine.find('Ticket');

        // Should find both Ticket types
        const packages = new Set(results.map(r => r.symbol.match(/npm\s+([^\s]+)/)?.[1]));
        expect(packages).toContain('@mdt/shared');
        expect(packages).toContain('markdown-ticket');
      });
    });
  });

  // @phase:2 @requirement:R3
  describe('Folder Scope Filtering (R3)', () => {
    describe('when --folder option filters by directory', () => {
      it('should return only occurrences within the specified folder', () => {
        const results = queryEngine.find('Ticket', {
          folder: 'src/'
        });

        // Should only include results from src/ directory
        expect(results.length).toBeGreaterThan(0);
        results.forEach(result => {
          expect(result.filePath).toMatch(/^src\//);
        });
      });

      it('should support nested folder paths', () => {
        const results = queryEngine.find('Ticket', {
          folder: 'shared/models/'
        });

        expect(results).toHaveLength(2); // Both occurrences in shared/models/Ticket.ts
        results.forEach(result => {
          expect(result.filePath).toMatch(/^shared\/models\//);
        });
      });

      it('should support folder without trailing slash', () => {
        const resultsWithSlash = queryEngine.find('Ticket', { folder: 'src/' });
        const resultsWithoutSlash = queryEngine.find('Ticket', { folder: 'src' });

        expect(resultsWithSlash).toEqual(resultsWithoutSlash);
      });
    });

    describe('when --folder is combined with --from', () => {
      it('should apply both filters', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts',
          folder: 'src/'
        });

        // Should only return occurrences from @mdt/shared Ticket in src/ folder
        expect(results).toHaveLength(1); // Only the import in src/TicketService.ts
        results.forEach(result => {
          expect(result.symbol).toContain('@mdt/shared');
          expect(result.filePath).toMatch(/^src\//);
        });
      });
    });

    describe('when --folder does not match any occurrences', () => {
      it('should return empty results', () => {
        const results = queryEngine.find('Ticket', {
          folder: 'nonexistent/folder/'
        });

        expect(results).toEqual([]);
      });
    });
  });

  // @phase:2 @requirement:R4
  describe('Package-Aware Distinction (R4)', () => {
    describe('when same-named symbols exist in different packages', () => {
      it('should distinguish symbols by package name', () => {
        const allResults = queryEngine.find('Ticket');

        const mdtSharedResults = allResults.filter(r =>
          r.symbol.includes('@mdt/shared')
        );
        const markdownResults = allResults.filter(r =>
          r.symbol.includes('markdown-ticket')
        );

        // Should have separate results for each package
        expect(mdtSharedResults).toHaveLength(4);
        expect(markdownResults).toHaveLength(2);
      });

      it('should allow filtering to specific package via --from', () => {
        const mdtResults = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });
        const markdownResults = queryEngine.find('Ticket', {
          from: 'src/types.ts'
        });

        // Results should be from different packages
        mdtResults.forEach(r => {
          expect(r.symbol).toContain('@mdt/shared');
        });
        markdownResults.forEach(r => {
          expect(r.symbol).toContain('markdown-ticket');
        });
      });
    });

    describe('when extracting package information from SCIP symbols', () => {
      it('should parse package name from SCIP symbol format', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        expect(results[0].symbol).toMatch(
          /scip-typescript\s+npm\s+@mdt\/shared\s+/
        );
      });

      it('should handle scoped package names (@scope/package)', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        expect(results[0].symbol).toContain('@mdt/shared');
      });

      it('should handle non-scoped package names', () => {
        const results = queryEngine.find('Ticket', {
          from: 'src/types.ts'
        });

        expect(results[0].symbol).toContain('markdown-ticket');
      });
    });
  });

  // @phase:2
  describe('Query Engine Options', () => {
    describe('when options object is empty', () => {
      it('should return all symbols matching the name', () => {
        const results = queryEngine.find('Ticket', {});

        expect(results).toHaveLength(6);
      });
    });

    describe('when options is undefined', () => {
      it('should return all symbols matching the name', () => {
        const results = queryEngine.find('Ticket');

        expect(results).toHaveLength(6);
      });
    });
  });

  // @phase:2
  describe('Result Structure', () => {
    describe('when returning query results', () => {
      it('should preserve all occurrence metadata', () => {
        const results = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        results.forEach(result => {
          expect(result).toHaveProperty('symbol');
          expect(result).toHaveProperty('filePath');
          expect(result).toHaveProperty('line');
          expect(result).toHaveProperty('column');
          expect(result).toHaveProperty('roles');
          expect(result).toHaveProperty('isDefinition');
        });
      });

      it('should return results in consistent order', () => {
        const results1 = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });
        const results2 = queryEngine.find('Ticket', {
          from: 'shared/models/Ticket.ts'
        });

        expect(results1).toEqual(results2);
      });
    });
  });

  // @phase:2
  describe('Performance', () => {
    describe('when querying large symbol index', () => {
      it('should complete query in under 1 second', () => {
        // Create a larger index
        const largeIndex = new Map();
        for (let i = 0; i < 1000; i++) {
          largeIndex.set(`package-${i}:file.ts:Symbol${i}`, [
            {
              symbol: `scip-typescript npm package-${i} 1.0.0 file/\`file.ts\`/Symbol${i}#`,
              filePath: `file-${i}.ts`,
              line: i,
              column: 0,
              roles: 1,
              isDefinition: true
            }
          ]);
        }
        const largeQueryEngine = new QueryEngine(largeIndex);

        const startTime = performance.now();
        largeQueryEngine.find('Symbol500');
        const endTime = performance.now();

        expect(endTime - startTime).toBeLessThan(1000); // < 1 second
      });
    });
  });

  // @phase:2
  describe('Edge Cases', () => {
    describe('when symbol name is empty', () => {
      it('should return empty results', () => {
        const results = queryEngine.find('');

        expect(results).toEqual([]);
      });
    });

    describe('when symbol name contains special characters', () => {
      it('should handle special characters gracefully', () => {
        const results = queryEngine.find('$Special');

        expect(results).toEqual([]);
      });
    });

    describe('when index is empty', () => {
      it('should return empty results', () => {
        const emptyEngine = new QueryEngine(new Map());
        const results = emptyEngine.find('Ticket');

        expect(results).toEqual([]);
      });
    });
  });
});
