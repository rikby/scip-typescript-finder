/**
 * Tests for: SCF-004 Phase 3
 * Phase: 3 - CLI Syntax Auto-Detection
 * Requirements: R3 (CLI Syntax Auto-Detection), R5 (Edge Case Handling)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import { detectQuerySyntax, stripMethodParameters } from '../../../src/cli/query-syntax';
import { SuffixType } from '../../../src/core/scip/SuffixType';

describe('Query Syntax Detection', () => {
  // @requirement:R3.1
  describe('when query ends with () or contains (', () => {
    it('should detect as method query', () => {
      expect(detectQuerySyntax('myMethod()')).toBe(SuffixType.Method);
      expect(detectQuerySyntax('MyThing.myMethod()')).toBe(SuffixType.Method);
      expect(detectQuerySyntax('process(data)')).toBe(SuffixType.Method);
    });

    it('should detect queries containing ( anywhere', () => {
      expect(detectQuerySyntax('findById(id: string)')).toBe(SuffixType.Method);
      expect(detectQuerySyntax('MyClass.method(param1, param2)')).toBe(SuffixType.Method);
    });
  });

  // @requirement:R3.2
  describe('when query contains . but no (', () => {
    it('should detect as property query', () => {
      expect(detectQuerySyntax('MyThing.myProp')).toBe(SuffixType.Term);
      expect(detectQuerySyntax('user.name')).toBe(SuffixType.Term);
      expect(detectQuerySyntax('config.host')).toBe(SuffixType.Term);
    });

    it('should detect nested properties', () => {
      expect(detectQuerySyntax('MyThing.nested.prop')).toBe(SuffixType.Term);
      expect(detectQuerySyntax('config.server.host')).toBe(SuffixType.Term);
    });
  });

  // @requirement:R3.3, @requirement:R3.6
  describe('when query is bare name (no . or ()', () => {
    it('should default to undefined (wildcard match)', () => {
      expect(detectQuerySyntax('process')).toBeUndefined();
      expect(detectQuerySyntax('Ticket')).toBeUndefined();
      expect(detectQuerySyntax('findById')).toBeUndefined();
    });

    it('should match both properties and methods in wildcard mode', () => {
      // Wildcard mode returns undefined, meaning "match all types"
      expect(detectQuerySyntax('handle')).toBeUndefined();
    });
  });

  // @requirement:R5.3
  describe('when getter/setter syntax is used', () => {
    it('should support property syntax for getter', () => {
      expect(detectQuerySyntax('value')).toBeUndefined(); // Bare name is wildcard
      expect(detectQuerySyntax('MyThing.value')).toBe(SuffixType.Term);
    });

    it('should support method syntax for getter with ()', () => {
      expect(detectQuerySyntax('getValue()')).toBe(SuffixType.Method);
      expect(detectQuerySyntax('MyThing.getValue()')).toBe(SuffixType.Method);
    });
  });

  // @requirement:R5.4
  describe('when query has edge case syntax', () => {
    it('should handle empty string gracefully', () => {
      expect(detectQuerySyntax('')).toBeUndefined();
    });

    it('should handle special characters', () => {
      expect(detectQuerySyntax('$prop')).toBeUndefined(); // Bare name
      expect(detectQuerySyntax('MyThing.$prop')).toBe(SuffixType.Term);
    });

    it('should handle just dot', () => {
      expect(detectQuerySyntax('.')).toBe(SuffixType.Term);
    });

    it('should handle just parentheses', () => {
      expect(detectQuerySyntax('()')).toBe(SuffixType.Method);
    });
  });
});

describe('Method Parameter Stripping', () => {
  // @requirement:R3.5, @requirement:R5.2
  describe('when method query has parameters', () => {
    it('should strip parameters to return base name', () => {
      expect(stripMethodParameters('method(string, number)')).toBe('method');
      expect(stripMethodParameters('findById(id: string)')).toBe('findById');
      expect(stripMethodParameters('process(data, options?)')).toBe('process');
    });

    it('should handle method without parameters', () => {
      expect(stripMethodParameters('method()')).toBe('method');
      expect(stripMethodParameters('MyThing.method()')).toBe('MyThing.method');
    });

    it('should handle nested method with parameters', () => {
      expect(stripMethodParameters('MyThing.nested.method(x, y)')).toBe('MyThing.nested.method');
    });
  });

  // @requirement:R5.1
  describe('when function-type property is queried', () => {
    it('should not strip parameters from property syntax', () => {
      // Properties don't have () in query syntax - user queries "onClick" not "onClick()"
      const prop = 'onClick';
      expect(stripMethodParameters(prop)).toBe(prop);
    });

    it('should preserve property names exactly', () => {
      expect(stripMethodParameters('myProp')).toBe('myProp');
      expect(stripMethodParameters('MyThing.callback')).toBe('MyThing.callback');
    });
  });

  describe('when query has edge cases', () => {
    it('should handle empty parentheses', () => {
      expect(stripMethodParameters('method()')).toBe('method');
    });

    it('should handle nested parentheses', () => {
      expect(stripMethodParameters('method(callback: () => void)')).toBe('method');
    });

    it('should handle unmatched parentheses gracefully', () => {
      expect(stripMethodParameters('method(')).toBe('method(');
      expect(stripMethodParameters('method)')).toBe('method)');
    });

    it('should handle no parentheses', () => {
      expect(stripMethodParameters('method')).toBe('method');
      expect(stripMethodParameters('MyThing.prop')).toBe('MyThing.prop');
    });
  });
});

describe('Query Syntax Integration', () => {
  describe('combining detection and stripping', () => {
    it('should detect method and strip parameters together', () => {
      const query = 'findById(id: string)';
      const detected = detectQuerySyntax(query);
      const stripped = stripMethodParameters(query);

      expect(detected).toBe(SuffixType.Method);
      expect(stripped).toBe('findById');
    });

    it('should detect property and leave unchanged', () => {
      const query = 'MyThing.myProp';
      const detected = detectQuerySyntax(query);
      const stripped = stripMethodParameters(query);

      expect(detected).toBe(SuffixType.Term);
      expect(stripped).toBe(query);
    });

    it('should detect wildcard for bare name', () => {
      const query = 'process';
      const detected = detectQuerySyntax(query);
      const stripped = stripMethodParameters(query);

      expect(detected).toBeUndefined();
      expect(stripped).toBe(query);
    });
  });
});
