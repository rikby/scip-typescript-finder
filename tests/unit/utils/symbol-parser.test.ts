/**
 * Tests for: SCF-001 Phase 1
 * Phase: 1 - Foundation (Symbol Parser Utilities)
 * Requirements: R2 (Definition File Filtering), R4 (Package-Aware Distinction), R5 (Declaration File Handling)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import {
  extractPackageName,
  extractDisplayName,
  extractFilePath,
  isDeclarationFile,
  normalizeSymbolPath,
  getSymbolKey
} from '../../../src/utils/symbol-parser.ts';

describe('Symbol Parser Utilities', () => {
  describe('extractPackageName', () => {
    // @phase:1 @requirement:R4
    describe('when given SCIP symbol from npm package', () => {
      it('should extract package name from standard npm package', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        expect(extractPackageName(symbol)).toBe('@mdt/shared');
      });

      it('should extract package name from scoped npm package', () => {
        const symbol = 'scip-typescript npm @scope/package 2.0.0 src/\\`index.ts\\`/foo#';
        expect(extractPackageName(symbol)).toBe('@scope/package');
      });

      it('should extract package name from unscoped npm package', () => {
        const symbol = 'scip-typescript npm lodash 4.17.21 lodash/\\`index.d.ts\\`/map#';
        expect(extractPackageName(symbol)).toBe('lodash');
      });
    });

    // @phase:1 @requirement:R4
    describe('when given SCIP symbol without package', () => {
      it('should return empty string', () => {
        const symbol = 'invalid symbol format';
        expect(extractPackageName(symbol)).toBe('');
      });
    });
  });

  describe('extractDisplayName', () => {
    // @phase:1 @requirement:R1
    describe('when given SCIP symbol with interface', () => {
      it('should extract interface name without # suffix', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        expect(extractDisplayName(symbol)).toBe('Ticket');
      });
    });

    // @phase:1 @requirement:R1
    describe('when given SCIP symbol with method', () => {
      it('should extract method name with ()', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/parseDate().';
        expect(extractDisplayName(symbol)).toBe('parseDate()');
      });

      it('should extract method name with parameters', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/findById(id:string).';
        expect(extractDisplayName(symbol)).toBe('findById(id:string)');
      });
    });

    // @phase:1 @requirement:R1
    describe('when given SCIP symbol with property', () => {
      it('should extract property name', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/id.';
        expect(extractDisplayName(symbol)).toBe('id');
      });
    });

    // @phase:1 @requirement:R1
    describe('when given invalid SCIP symbol', () => {
      it('should return empty string', () => {
        expect(extractDisplayName('invalid')).toBe('');
      });
    });
  });

  describe('extractFilePath', () => {
    // @phase:1 @requirement:R2
    describe('when given SCIP symbol with file path', () => {
      it('should extract file path from backtick-enclosed path', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        expect(extractFilePath(symbol)).toBe('models/Ticket.ts');
      });

      it('should handle nested directory paths', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 src/utils/helpers/\\`date.ts\\`/parse().';
        expect(extractFilePath(symbol)).toBe('src/utils/helpers/date.ts');
      });
    });

    // @phase:1 @requirement:R2
    describe('when given SCIP symbol with declaration file', () => {
      it('should extract .d.ts file path', () => {
        const symbol = 'scip-typescript npm lodash 4.17.21 lodash/\\`index.d.ts\\`/map#';
        expect(extractFilePath(symbol)).toBe('lodash/index.d.ts');
      });
    });
  });

  describe('isDeclarationFile', () => {
    // @phase:1 @requirement:R5
    describe('when given file paths', () => {
      it('should return true for .d.ts declaration file', () => {
        expect(isDeclarationFile('models/Ticket.d.ts')).toBe(true);
        expect(isDeclarationFile('index.d.ts')).toBe(true);
      });

      it('should return false for .ts source file', () => {
        expect(isDeclarationFile('models/Ticket.ts')).toBe(false);
        expect(isDeclarationFile('index.ts')).toBe(false);
      });

      it('should return false for non-TypeScript files', () => {
        expect(isDeclarationFile('models/Ticket.js')).toBe(false);
        expect(isDeclarationFile('README.md')).toBe(false);
      });
    });
  });

  describe('normalizeSymbolPath', () => {
    // @phase:1 @requirement:R5
    describe('when given .ts and .d.ts variants', () => {
      it('should normalize .d.ts to .ts for same source file', () => {
        expect(normalizeSymbolPath('models/Ticket.d.ts')).toBe('models/Ticket.ts');
        expect(normalizeSymbolPath('models/Ticket.ts')).toBe('models/Ticket.ts');
      });
    });

    // @phase:1 @requirement:R5
    describe('when given declaration file path', () => {
      it('should replace .d.ts suffix with .ts', () => {
        expect(normalizeSymbolPath('index.d.ts')).toBe('index.ts');
        expect(normalizeSymbolPath('src/utils/helpers.d.ts')).toBe('src/utils/helpers.ts');
      });
    });

    // @phase:1 @requirement:R5
    describe('when given non-declaration file path', () => {
      it('should return original path unchanged', () => {
        expect(normalizeSymbolPath('models/Ticket.ts')).toBe('models/Ticket.ts');
        expect(normalizeSymbolPath('index.js')).toBe('index.js');
      });
    });
  });

  describe('getSymbolKey', () => {
    // @phase:1 @requirement:R4
    describe('when creating lookup keys for symbols', () => {
      it('should create key from package, file, and display name', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        const key = getSymbolKey(symbol);
        expect(key).toBe('@mdt/shared:models/Ticket.ts:Ticket');
      });

      it('should normalize declaration files to source files in key', () => {
        const symbol = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.d.ts\\`/Ticket#';
        const key = getSymbolKey(symbol);
        expect(key).toBe('@mdt/shared:models/Ticket.ts:Ticket');
      });
    });

    // @phase:1 @requirement:R4
    describe('when given symbols with same display name from different packages', () => {
      it('should create different keys for different packages', () => {
        const symbol1 = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        const symbol2 = 'scip-typescript npm markdown-ticket 0.0.0 src/\\`types.ts\\`/Ticket#';
        const key1 = getSymbolKey(symbol1);
        const key2 = getSymbolKey(symbol2);
        expect(key1).not.toBe(key2);
        expect(key1).toContain('@mdt/shared');
        expect(key2).toContain('markdown-ticket');
      });
    });

    // @phase:1 @requirement:R4
    describe('when given symbols with same display name from same package different files', () => {
      it('should create different keys including file path', () => {
        const symbol1 = 'scip-typescript npm @mdt/shared 1.0.0 models/\\`Ticket.ts\\`/Ticket#';
        const symbol2 = 'scip-typescript npm @mdt/shared 1.0.0 types/\\`Ticket.ts\\`/Ticket#';
        const key1 = getSymbolKey(symbol1);
        const key2 = getSymbolKey(symbol2);
        expect(key1).not.toBe(key2);
        expect(key1).toContain('models/Ticket.ts');
        expect(key2).toContain('types/Ticket.ts');
      });
    });
  });
});
