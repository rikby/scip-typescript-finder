/**
 * Tests for: SCF-001 Phase 1
 * Phase: 1 - Foundation (Symbol Roles Utilities)
 * Requirements: R10 (Symbol Role Identification)
 * Generated by: /mdt:tests
 * Status: RED (implementation pending)
 */

import {
  getRoleName,
  getRoleNames,
  isDefinition,
  isReference,
  isImport,
  isExport
} from '../../../src/utils/symbol-roles.ts';

describe('Symbol Roles Utilities', () => {
  describe('getRoleName', () => {
    // @phase:1 @requirement:R10
    describe('when given a valid role bitmask', () => {
      it('should return "Definition" for definition role (0x1)', () => {
        expect(getRoleName(0x1)).toBe('Definition');
      });

      it('should return "Reference" for reference role (0x2)', () => {
        expect(getRoleName(0x2)).toBe('Reference');
      });

      it('should return "Import" for import role (0x4)', () => {
        expect(getRoleName(0x4)).toBe('Import');
      });

      it('should return "Export" for export role (0x8)', () => {
        expect(getRoleName(0x8)).toBe('Export');
      });
    });

    // @phase:1 @requirement:R10
    describe('when given an unknown role bitmask', () => {
      it('should return "Unknown" for unrecognized role (0x100)', () => {
        expect(getRoleName(0x100)).toBe('Unknown');
      });

      it('should return "Unknown" for zero bitmask', () => {
        expect(getRoleName(0)).toBe('Unknown');
      });
    });
  });

  describe('getRoleNames', () => {
    // @phase:1 @requirement:R10
    describe('when symbol has multiple roles', () => {
      it('should return array of all role names for combined bitmask', () => {
        // Definition + Import = 0x1 | 0x4 = 0x5
        const roles = getRoleNames(0x5);
        expect(roles).toEqual(expect.arrayContaining(['Definition', 'Import']));
        expect(roles).toHaveLength(2);
      });

      it('should return all four role names for full bitmask', () => {
        // All roles = 0x1 | 0x2 | 0x4 | 0x8 = 0xF
        const roles = getRoleNames(0xF);
        expect(roles).toEqual(['Definition', 'Reference', 'Import', 'Export']);
      });
    });

    // @phase:1 @requirement:R10
    describe('when symbol has single role', () => {
      it('should return array with one role name', () => {
        const roles = getRoleNames(0x1);
        expect(roles).toEqual(['Definition']);
      });
    });

    // @phase:1 @requirement:R10
    describe('when symbol has unknown roles', () => {
      it('should exclude unknown bits from results', () => {
        // Definition + unknown bit = 0x1 | 0x100 = 0x101
        const roles = getRoleNames(0x101);
        expect(roles).toEqual(['Definition']);
      });

      it('should return empty array for all unknown bits', () => {
        const roles = getRoleNames(0xFF00);
        expect(roles).toEqual([]);
      });
    });
  });

  describe('isDefinition', () => {
    // @phase:1 @requirement:R10
    it('should return true when definition bit is set', () => {
      expect(isDefinition(0x1)).toBe(true);
      expect(isDefinition(0x3)).toBe(true); // Definition + Reference
      expect(isDefinition(0x5)).toBe(true); // Definition + Import
    });

    // @phase:1 @requirement:R10
    it('should return false when definition bit is not set', () => {
      expect(isDefinition(0x2)).toBe(false);
      expect(isDefinition(0x4)).toBe(false);
      expect(isDefinition(0)).toBe(false);
    });
  });

  describe('isReference', () => {
    // @phase:1 @requirement:R10
    it('should return true when reference bit is set', () => {
      expect(isReference(0x2)).toBe(true);
      expect(isReference(0x3)).toBe(true); // Definition + Reference
      expect(isReference(0x6)).toBe(true); // Reference + Import
    });

    // @phase:1 @requirement:R10
    it('should return false when reference bit is not set', () => {
      expect(isReference(0x1)).toBe(false);
      expect(isReference(0x4)).toBe(false);
      expect(isReference(0)).toBe(false);
    });
  });

  describe('isImport', () => {
    // @phase:1 @requirement:R10
    it('should return true when import bit is set', () => {
      expect(isImport(0x4)).toBe(true);
      expect(isImport(0x5)).toBe(true); // Definition + Import
      expect(isImport(0x6)).toBe(true); // Reference + Import
    });

    // @phase:1 @requirement:R10
    it('should return false when import bit is not set', () => {
      expect(isImport(0x1)).toBe(false);
      expect(isImport(0x2)).toBe(false);
      expect(isImport(0)).toBe(false);
    });
  });

  describe('isExport', () => {
    // @phase:1 @requirement:R10
    it('should return true when export bit is set', () => {
      expect(isExport(0x8)).toBe(true);
      expect(isExport(0x9)).toBe(true); // Definition + Export
      expect(isExport(0xA)).toBe(true); // Reference + Export
    });

    // @phase:1 @requirement:R10
    it('should return false when export bit is not set', () => {
      expect(isExport(0x1)).toBe(false);
      expect(isExport(0x2)).toBe(false);
      expect(isExport(0)).toBe(false);
    });
  });
});
